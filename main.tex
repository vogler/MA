%\chapter{Introduction}



\chapter{Static analysis and Goblint}
\section{Overview}

\section{Theory}

\section{Getting started}
Appendix: Setup
Adding an own analysis


\chapter{Verifying correct usage of file handles}
\section{Common problems using files}
The following examples for common problems served as a guideline for the implementation and contain comments starting with \verb|WARN: | that indicate where warnings would be output.

\refListing{01-ok.c} shows opening a file \verb|log.txt| and appending the line "Testing..." to it. At the end the file is closed.
\listingC{01-ok.c}{Everything fine?}

\paragraph*{fopen}
This might seem fine, since the file will be created if it doesn't exist, but what happens if the file can't be written to?
If the file exists but we don't have write access, running the code will result in a segmentation fault at \verb|fprintf|.
We forgot to check the result of \verb|fopen| which returns an error code if the file couldn't be opened successfully.
This case is handled by the implementation and can also be checked using the specification language. In this example warnings should be issued that the file handle might not be open after line 5.

A corrected version could look like \refListing{02-ok-checked.c}.
\listingC{02-ok-checked.c}{Success check for fopen}
For brevity reasons a success check is omitted in the following examples and it's assumed that the file could be opened without errors. The specification version can be easily adjusted to conform to this by just replacing a few states, whereas the manual implementation would always warn about maybe unopened file handles.

\refListing{03-no-open.c} shows what happens if the file handle was not opened before using it. When running the program, this leads to a segmentation fault.
\listingC{03-no-open.c}{Missing fopen}

\paragraph*{fclose}
Not closing files is not necessarily an error since file handles are closed at the end of the program anyway, but it's not good practice and might lead to unwanted behavior.
Imagine a program that is done writing important information to a file but doesn't close it. What happens if the program gets stuck in calculations or on user input and other programs want to use the file? See \refListing{04-user-input.c} for example. Without the call to \verb|fclose|, the written content might not be flushed until the program terminates. Running with some content in the file resulted in an empty file at the point of user input.
\listingC{04-user-input.c}{Motivation for fclose: flushing}

\refListing{05-no-close.c} has comments for warnings that would be issued. There is a warning where the file was opened and a summary of unclosed files at the end of the program.
\listingC{05-no-close.c}{Missing fclose}

\paragraph*{fprintf}
Writing to a file which is opened read-only as demonstrated in \refListing{06-open-mode.c} is another problem. Bugs of this kind might be hard to find, since this executes without errors - there is just nothing written to the file.
\listingC{06-open-mode.c}{Wrong open mode}

Other functions like \verb|fscanf, fputc, fgetc, fwrite, fread| are not analyzed, since the problems are similar to \verb|fprintf|.


\section{A domain for representing file handle usage}
Since the program behavior is merely approximated, one has to differentiate between information that may or must be true. For illustration May- and Must-Sets with their corresponding join operation and the meaning of the empty set are described below.
\begin{description}
\item[Must-Set] Property must be true for all elements, but not all elements with the property must be in the set. $\sqcap = \cap$, $\emptyset = \top$.
\item[May-Set] Property may be true or not for each element, but all elements for which  it is true must be in the set. $\sqcap = \cup$, $\emptyset = \bot$.
\end{description}
If the sets contain elements we want to warn about, then the difference concerning warnings is described below.
\begin{description}
\item[Must-Set] Precision: every warning is an error, but the program may still have errors.
\item[May-Set] Soundness: there might be false positives, but if there are no warnings, then the program is error-free.
\end{description}

Since it should be possible to track multiple file handles, a map \textbf{M} from variables (or better LValues) \textbf{K} to another domain \textbf{V} is needed. The bottom value for \textbf{M} is the empty map.
The domain \textbf{V} represents one file handle. \refListing{fileDomainType.ml} shows how its type \verb|t| is defined.
\listingML{fileDomainType.ml}{Type of the file handle domain}
\begin{description}
\item[t'] Must and May don't correspond to the sets from above but describe something different here. As long as the file handle is safely described, \verb|Must ...| is used. As soon as there might be multiple possible records, \verb|May ...| is used. There are some special cases which we will come to later.

\item[record] contains the variable \verb|var| that was used as a key, the location stack \verb|loc| and \verb|state|.

\item[state] can be \verb|Open(filename, mode)| or \verb|Close|.

\item[mode] can be \verb|Read| if the file is opened read-only with mode \verb|r| or \verb|Write| for all other modes.

\item[loc] is a stack of locations from the assignment to \verb|var| down to the use of the stdio-function. It is maintained as a special value inside \textbf{M}. On entering a function, the location of the call site is pushed, and popped again when leaving the function.
\end{description}
The location stack is kept because the location of the stdio-function might not always be the location where the warning should be issued. \refListing{07-location-stack.c} defines a custom function for opening files. The warnings should be placed at the call to this function instead of at the call to \verb|fopen|.
% TODO does this work correctly??
\listingC{07-location-stack.c}{Location of warning when using custom function for opening files}
However, using a normal stack could lead to infinite ascending chains as shown in \refListing{08-location-stack-chain.c}. Once the uninitialized variable \verb|b| contains 0, the file will be opened. This normally happens pretty fast before overflowing the callstack. So the program runs fine, but the analysis would get stuck with an ever growing location stack. To avoid this, the location stack behaves as an ordered set, i.e. if a location is already contained in the stack, it won't be pushed. % TODO check code!
\listingC{08-location-stack-chain.c}{Infinitely growing location stack}
TODO: limitation:
\listingC{09-location-stack-alternate.c}{Mutually recursive functions and the location stack}
As mentioned above, there are some special cases concerning May-Sets:
\begin{itemize}
\item The empty set represents \textbf{V}'s bottom element: \verb|May {}| $ = \bot$
\item The set with exactly one element \verb|May {x}| means that that the record \verb|x| might not safely describe the file handle anymore because of an unsupported operation (e.g. pointer arithmetic).
\item The set with more than one element \verb|May {x, y, z ...}| contains possible alternative records. 

Even if the correct one is not known, these alternatives can be used to answer questions about the state during the analysis.

Assume for example that the set contains records with the states \verb|Open(..., Read)| and \verb|Open(..., Write)|. In this case it is safe to say that the file is opened - if it is writable on the other hand is unknown. Another example: all states are \verb|Close| but with different locations. %  TODO: is this ok for join? how is it done?
\end{itemize}
% describe join
The join operation for \textbf{V} is the union of all records, with the exception of 1-element May-Sets which lead to the set itself:
%\verb|join x y = {records of x}| $\cup$ \verb|{records of y}|.\\
\begin{align*}
join(x,y)=\left\{\begin{array}{cl}
records(x), & \mbox{if }may(x) \wedge |records(x)|=1\\
records(y), & \mbox{if }may(y) \wedge |records(y)|=1\\
records(x) \cup records(y), & \mbox{else} \end{array}\right.
\end{align*}


\section{An analysis for checking file handle usage}

\section{Soundness vs. Precision}


\chapter{A general specification for regular safety properties}
\section{Interesting types of constraints}

\section{Representing the state of properties using an automaton}

\section{Specification format}

\section{Shortcuts for making the specification more concise}
More sane/human-readable.


\chapter{Example use cases}
%http://smallcultfollowing.com/babysteps/pubs/2013.07.17-NEU.pdf
%What Rust doesn’t have...
%– Null pointers
%– Dangling pointers
%– Segmentation faults
%– Data races
%– Mandatory GC

\section{File handles redux}

\section{Locks}
Different kinds of locks + table of functions for them.
Locks with counters not regular -> see extenstions.

\section{Heap usage: malloc and free}


\chapter{Providing a better interface}
\section{Web frontend}
Screenshots.
Online version.


\chapter{Tests and real world examples}
Test some specifications on kernel code?
Benchmarks?


\chapter{Ideas for further development}
\section{Non-regular safety properties}
E.g. locks with counters.


\chapter{Conclusion}

